在任何语言里，栈上的值都有自己的生命周期，它和栈帧的生命周期一致，Rust 进一步明确了这个概念，并为堆上的内存也引入了生命周期。

在其他语言中，堆内存的生命周期是不确定的，或者说是未定义的。在 Rust 中，除非显式地做 `Box::leak()` / `Box::into_raw()` / `ManualDrop` 等动作，**一般来说，堆内存的生命周期，会默认和其栈内存的生命过周期绑定在一起。**

Rust 编译器会对比值和其引用的生命周期，来确保**引用的生命周期不会超出值的生命周期。**

## 值的生命周期

1. 如果一个值的生命周期贯穿整个进程的生命周期，那么称这种生命周期为**静态生命周期。**
    - 使用 `'static` 来表示，比如 `&'static` 表示一个具有静态生命周期的字符串引用。
    - 一般来说，全局变量、静态变量、字符串字面量都拥有静态生命周期，堆内存如果使用了 `Box::leak` 后也有静态生命周期。
2. 当一个值是在某个作用域内定义的，也就是说它被创建在栈上或堆上，那么其生命周期也是动态的。当作用域结束，值的生命周期也随之结束。
    - 动态生命周期，约定使用 `'a`、`'b` 或者 `'hello` 这样的小写字符来表示，`'` 后面具体是什么名字不重要，它表示一段动态的生命周期。`'a` 和 `'b` 表示这两个字符串引用的生命周期可能不一致，

---

生命周期参数描述的是参数和参数之间、参数和返回值之间的关系，并不改变原有的生命周期。

部分情况下我们无需做生命周期标注，编译器会通过一些简单规则为函数自动添加标注：
1. 所有引用类型的参数都有独立的生命周期
2. 如果只有一个引用型输入，它的生命周期会赋给所有输出
3. 如果有多个引用类型的参数，其中一个是 self，那么它的生命周期会赋给所有输出

