当进行变量赋值、传参和函数返回时，如果数据结构没有实现 Copy trait，就会默认使用 Move 语义转移值的所有权。

当不希望值的所有权被转移，又因为没有实现 Copy trait 而无法使用 Copy 语义时，可以使用 Borrow 语义。

Borrow 只是借出了临时使用权，通过引用语法 `&` 或者 `&mut` 来实现。

在 Rust 中借用和引用是一个概念。

在其他语言中，引用是一种别名，多个引用拥有对值的无差别的访问权限，本质上是共享了所有权，在 Rust 中，所有的引用都只是借用了临时的使用权，并不破坏值的单一所有权约束。

**Rust 所有的参数传递都是值传递。** 不管是 Copy 还是 Move，在 Rust 中必须显式地把某个数据引用传递给另一个函数。

Rust 的引用实现了 Copy trait，所以按照 Copy 语义，这个引用会被复制一份交给要调用的函数。对这个函数来说，它不拥有数据本身，数据只是临时借给他使用，所有权还在原来的函数那里。

